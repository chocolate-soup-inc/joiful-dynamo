"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseMapping_1 = __importDefault(require("./parseMapping"));
const parseCompositeKey_1 = __importDefault(require("./parseCompositeKey"));
const utils_1 = require("./utils");
exports.default = (attributes, track) => {
    // Parse attributes into standard format
    attributes = Object.keys(attributes).reduce((acc, field) => {
        // If a string value
        if (typeof attributes[field] === 'string') {
            // If invalid type, throw error
            if (!utils_1.validTypes.includes(attributes[field].toString())) {
                utils_1.typeError(field);
            }
            // Merge and return mapping
            return Object.assign(acc, parseMapping_1.default(field, { type: attributes[field] }, track));
            // If an array
        }
        else if (Array.isArray(attributes[field])) {
            return Object.assign(acc, parseCompositeKey_1.default(field, attributes[field], track, attributes));
            // Else if complex mapping
        }
        else {
            // TODO: Is there a better way to do this without casting this value?
            const fieldVal = attributes[field];
            // Default field to 'string'
            fieldVal.type = !fieldVal.type ? 'string' : fieldVal.type;
            if (!utils_1.validTypes.includes(fieldVal.type)) {
                utils_1.typeError(field);
            }
            return Object.assign(acc, parseMapping_1.default(field, fieldVal, track));
        }
    }, {});
    // Check that a partitionKey was defined (additional checks done when adding table)
    if (!track.keys.partitionKey)
        utils_1.error('Entity requires a partitionKey attribute');
    // Return keys and attributes
    return {
        keys: track.keys,
        attributes: attributes
    };
}; // end parseEntityAttrbutes
