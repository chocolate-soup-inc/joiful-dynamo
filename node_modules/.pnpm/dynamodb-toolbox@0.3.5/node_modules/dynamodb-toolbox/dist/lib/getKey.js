"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const validateTypes_1 = __importDefault(require("./validateTypes"));
const utils_1 = require("./utils");
// Get partitionKey/sortKey
exports.default = (DocumentClient) => (data, schema, partitionKey, sortKey) => {
    // TODO: Think about a better way to reference pk/sk - can it work with secondary indexes?
    partitionKey = schema[partitionKey].map || partitionKey;
    sortKey = (schema[sortKey] && schema[sortKey].map) || sortKey || null;
    // Intialize validate type
    let validateType = validateTypes_1.default(DocumentClient);
    // TODO: Add tests for 0 values
    let pk = data[partitionKey];
    if (pk === undefined || pk === null || pk === '') {
        utils_1.error(`'${partitionKey}'${schema[partitionKey].alias ? ` or '${schema[partitionKey].alias}'` : ''} is required`);
    }
    const sk = data[sortKey];
    if (sortKey && (sk === undefined || sk === null || sk === '')) {
        utils_1.error(`'${sortKey}'${schema[sortKey].alias ? ` or '${schema[sortKey].alias}'` : ''} is required`);
    }
    return Object.assign({ [partitionKey]: utils_1.transformAttr(schema[partitionKey], validateType(schema[partitionKey], partitionKey, pk), data) }, sortKey !== null ? { [sortKey]: utils_1.transformAttr(schema[sortKey], validateType(schema[sortKey], sortKey, sk), data) } : {}); // end assign
}; // end get keys
