"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTable = void 0;
// Import libraries, types, and classes
const parseTableAttributes_1 = __importDefault(require("./parseTableAttributes"));
const utils_1 = require("./utils");
// Parse table
const parseTable = (table) => {
    let { name, // Table name
    alias, // For batch references
    partitionKey, sortKey, entityField, attributes, indexes, autoExecute, autoParse, removeNullAttributes, entities, DocumentClient } = table, args = __rest(table
    // Error on extraneous arguments
    , ["name", "alias", "partitionKey", "sortKey", "entityField", "attributes", "indexes", "autoExecute", "autoParse", "removeNullAttributes", "entities", "DocumentClient"]) // extraneous config
    ;
    // Error on extraneous arguments
    if (Object.keys(args).length > 0)
        utils_1.error(`Invalid Table configuration options: ${Object.keys(args).join(', ')}`);
    // Table name
    name = typeof name === 'string' && name.trim().length > 0 ? name.trim()
        : utils_1.error(`'name' must be defined`);
    // Verify alias
    alias = typeof alias === 'string'
        && alias.trim().length > 0 ? alias.trim()
        : alias ? utils_1.error(`'alias' must be a string value`)
            : null;
    // Specify partitionKey attribute
    partitionKey = typeof partitionKey === 'string'
        && partitionKey.trim().length > 0 ? partitionKey.trim()
        : utils_1.error(`'partitionKey' must be defined`);
    // Specify sortKey attribute (optional)
    sortKey = typeof sortKey === 'string'
        && sortKey.trim().length > 0 ? sortKey.trim()
        : sortKey ? utils_1.error(`'sortKey' must be a string value`)
            : null;
    // Disable, or rename field for entity tracking
    entityField = entityField === false ? false
        : typeof entityField === 'string' && entityField.trim().length > 0 ?
            entityField.trim()
            : '_et';
    // Parse table attributes
    attributes = utils_1.hasValue(attributes) && typeof attributes === 'object' && !Array.isArray(attributes) ?
        attributes
        : attributes ? utils_1.error(`Please provide a valid 'attributes' object`)
            : {};
    // Add entityField to attributes
    if (entityField)
        attributes[entityField] = 'string';
    // Parse indexes (optional)
    indexes = utils_1.hasValue(indexes) && typeof indexes === 'object' && !Array.isArray(indexes) ?
        parseIndexes(indexes, partitionKey)
        : indexes ? utils_1.error(`Please provide a valid 'indexes' object`)
            : {};
    // Return the table
    return Object.assign({
        name,
        alias,
        Table: {
            partitionKey,
            sortKey,
            entityField,
            attributes: parseTableAttributes_1.default(attributes, partitionKey, sortKey),
            indexes
        },
        autoExecute,
        autoParse,
        removeNullAttributes,
        _entities: [] // init Entity tracker
    }, DocumentClient ? { DocumentClient } : {}, // end DocumentClient
    entities ? { entities } : {} // end entities
    );
}; // end parseTable
exports.parseTable = parseTable;
// Parse Indexes
const parseIndexes = (indexes, pk) => Object.keys(indexes).reduce((acc, index) => {
    // TODO: indexes can not be named TABLE
    // Destructure the index
    const _a = indexes[index], { partitionKey, sortKey } = _a, args = __rest(_a, ["partitionKey", "sortKey"]);
    // Error on extraneous arguments
    if (Object.keys(args).length > 0)
        utils_1.error(`Invalid index options: ${Object.keys(args).join(', ')}`);
    // Verify partitionKey
    if (partitionKey && typeof partitionKey !== 'string')
        utils_1.error(`'partitionKey' for ${index} must be a string`);
    // Verify sortKey
    if (sortKey && typeof sortKey !== 'string')
        utils_1.error(`'sortKey' for ${index} must be a string`);
    // Verify the presences of either pk or sk
    if (!sortKey && !partitionKey)
        utils_1.error(`A 'partitionKey', 'sortKey' or both, must be provided for ${index}`);
    // Guess index type
    const type = !partitionKey || partitionKey === pk ? 'LSI' : 'GSI';
    // Return the structured index object
    return Object.assign(acc, {
        [index]: Object.assign({}, partitionKey && type === 'GSI' ? { partitionKey } : {}, sortKey ? { sortKey } : {}, { type }) // end
    });
}, {});
exports.default = exports.parseTable;
