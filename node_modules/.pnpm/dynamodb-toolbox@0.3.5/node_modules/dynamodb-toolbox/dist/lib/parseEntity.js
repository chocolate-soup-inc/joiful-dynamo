"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEntity = void 0;
// Import libraries & types
const parseEntityAttributes_1 = __importDefault(require("./parseEntityAttributes"));
// Import error handlers
const utils_1 = require("./utils");
// Parse entity
function parseEntity(entity) {
    let { name, timestamps, created, createdAlias, modified, modifiedAlias, typeAlias, attributes, autoExecute, autoParse, table } = entity, args = __rest(entity
    // TODO: verify string types (e.g. created)
    // Error on extraneous arguments
    , ["name", "timestamps", "created", "createdAlias", "modified", "modifiedAlias", "typeAlias", "attributes", "autoExecute", "autoParse", "table"]) // extraneous config
    ;
    // TODO: verify string types (e.g. created)
    // Error on extraneous arguments
    if (Object.keys(args).length > 0)
        utils_1.error(`Invalid Entity configuration options: ${Object.keys(args).join(', ')}`);
    // Entity name
    name = typeof name === 'string'
        && name.trim().length > 0 ? name.trim()
        : utils_1.error(`'name' must be defined`);
    // Enable created/modified timestamps on items
    timestamps = typeof timestamps === 'boolean' ? timestamps : true;
    // Define 'created' attribute name
    created = typeof created === 'string'
        && created.trim().length > 0 ? created.trim()
        : '_ct';
    // Define 'createdAlias'
    createdAlias = typeof createdAlias === 'string'
        && createdAlias.trim().length > 0 ? createdAlias.trim()
        : 'created';
    // Define 'modified' attribute anme
    modified = typeof modified === 'string'
        && modified.trim().length > 0 ? modified.trim()
        : '_md';
    // Define 'modifiedAlias'
    modifiedAlias = typeof modifiedAlias === 'string'
        && modifiedAlias.trim().length > 0 ? modifiedAlias.trim()
        : 'modified';
    // Define 'entityAlias'
    typeAlias = typeof typeAlias === 'string'
        && typeAlias.trim().length > 0 ? typeAlias.trim()
        : 'entity';
    // Sanity check the attributes
    attributes = typeof attributes === 'object' && !Array.isArray(attributes) ?
        attributes : utils_1.error(`Please provide a valid 'attributes' object`);
    // Add timestamps
    if (timestamps) {
        attributes[created] = { type: 'string', alias: createdAlias, default: () => new Date().toISOString() };
        attributes[modified] = { type: 'string', alias: modifiedAlias, default: () => new Date().toISOString(), onUpdate: true };
    }
    // Tracking info
    let track = {
        fields: Object.keys(attributes),
        defaults: {},
        required: {},
        linked: {},
        keys: {} // tracks partition/sort/index keys
    };
    // Return the entity
    return Object.assign({
        name,
        schema: parseEntityAttributes_1.default(attributes, track),
        defaults: track.defaults,
        required: track.required,
        linked: track.linked,
        autoExecute,
        autoParse,
        _etAlias: typeAlias
    }, table ? { table } : {}); // end mapping object
} // end parseEntity
exports.parseEntity = parseEntity;
exports.default = parseEntity;
