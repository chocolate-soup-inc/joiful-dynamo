"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
// Parse the attributes and verify valid types
exports.default = (attrs, partitionKey, sortKey) => Object.keys(attrs).reduce((acc, field) => {
    if (typeof attrs[field] === 'string') {
        // TODO: Calling .toString() to satisfy TS even though I'm type checking
        // Error if invalid key type
        if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(attrs[field].toString())) {
            utils_1.keyTypeError(field);
        }
        // Error if invalid type
        if (!utils_1.validTypes.includes(attrs[field].toString())) {
            utils_1.typeError(field);
        }
        // Merge and return parsed attribute
        return Object.assign(acc, parseAttributeConfig(field, { type: attrs[field] }));
    }
    else {
        // TODO: Is there a better way to do this without casting this value?
        const fieldVal = attrs[field];
        // Error if invalid key type
        if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(fieldVal.type)) {
            utils_1.keyTypeError(field);
        }
        // Error if invalid type
        if (!utils_1.validTypes.includes(fieldVal.type)) {
            utils_1.typeError(field);
        }
        // Merge and return parsed attribute
        return Object.assign(acc, parseAttributeConfig(field, fieldVal));
    } // end else
}, {});
// Parse and validate attributes config
const parseAttributeConfig = (field, config) => {
    // Validate props
    Object.keys(config).forEach(prop => {
        switch (prop) {
            case 'type':
                break;
            case 'setType':
                if (config.type !== 'set')
                    utils_1.error(`'setType' is only valid for type 'set'`);
                if (!['string', 'number', 'binary'].includes(config[prop]))
                    utils_1.error(`Invalid 'setType', must be 'string', 'number', or 'binary'`);
                break;
            default:
                utils_1.error(`'${prop}' is not a valid property type`);
        }
    });
    return {
        [field]: Object.assign(Object.assign({}, config), { mappings: {} })
    };
};
