"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
// Performs type validation/coercian
exports.default = (DocumentClient) => (mapping, field, value) => {
    // Evaluate function expressions
    // TODO: should this happen here?
    // let value = typeof input === 'function' ? input(data) : input
    // return if undefined or null
    if (!utils_1.hasValue(value))
        return value;
    switch (mapping.type) {
        case 'string':
            return typeof value === 'string' || mapping.coerce ? String(value)
                : utils_1.error(`'${field}' must be of type string`);
        case 'boolean':
            return typeof value === 'boolean' || mapping.coerce ? utils_1.toBool(value)
                : utils_1.error(`'${field}' must be of type boolean`);
        case 'number':
            return typeof value === 'number' || mapping.coerce ?
                (String(parseInt(value)) === String(value) ? parseInt(value)
                    : String(parseFloat(value)) === String(value) ? parseFloat(value)
                        : utils_1.error(`Could not convert '${value}' to a number for '${field}'`))
                : utils_1.error(`'${field}' must be of type number`);
        case 'list':
            return Array.isArray(value) ? value
                : mapping.coerce ? String(value).split(',').map(x => x.trim())
                    : utils_1.error(`'${field}' must be a list (array)`);
        case 'map':
            return typeof value === 'object' && !Array.isArray(value) ? value
                : utils_1.error(`'${field}' must be a map (object)`);
        case 'set':
            if (Array.isArray(value)) {
                if (!DocumentClient)
                    utils_1.error('DocumentClient required for this operation');
                let set = DocumentClient.createSet(value, { validate: true });
                return !mapping.setType || mapping.setType === set.type.toLowerCase() ? set
                    : utils_1.error(`'${field}' must be a valid set (array) containing only ${mapping.setType} types`);
            }
            else if (mapping.coerce) {
                if (!DocumentClient)
                    utils_1.error('DocumentClient required for this operation');
                let set = DocumentClient.createSet(String(value).split(',').map(x => x.trim()));
                return !mapping.setType || mapping.setType === set.type.toLowerCase() ? set
                    : utils_1.error(`'${field}' must be a valid set (array) of type ${mapping.setType}`);
            }
            else {
                return utils_1.error(`'${field}' must be a valid set (array)`);
            }
        default:
            // TODO: Binary validation
            return value;
    }
}; // end validateTypes
