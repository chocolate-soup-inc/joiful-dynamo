"use strict";
/**
 * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB
 * @author Jeremy Daly <jeremy@jeremydaly.com>
 * @license MIT
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseEntity_1 = __importDefault(require("../lib/parseEntity"));
const validateTypes_1 = __importDefault(require("../lib/validateTypes"));
const normalizeData_1 = __importDefault(require("../lib/normalizeData"));
const formatItem_1 = __importDefault(require("../lib/formatItem"));
const getKey_1 = __importDefault(require("../lib/getKey"));
const expressionBuilder_1 = __importDefault(require("../lib/expressionBuilder"));
const projectionBuilder_1 = __importDefault(require("../lib/projectionBuilder"));
// Import error handlers
const utils_1 = require("../lib/utils");
// Declare Entity class
class Entity {
    // Declare constructor (entity config)
    constructor(entity) {
        // Sanity check the entity object
        if (typeof entity !== 'object' || Array.isArray(entity))
            utils_1.error('Please provide a valid entity definition');
        // Parse the entity and merge into this
        Object.assign(this, parseEntity_1.default(entity));
    } // end construcor
    // Set the Entity's Table
    set table(table) {
        // If a Table
        if (table.Table && table.Table.attributes) {
            // If this Entity already has a Table, throw an error
            if (this._table) {
                utils_1.error(`This entity is already assigned a Table (${this._table.name})`);
                // Else if the Entity doesn't exist in the Table, add it
            }
            else if (!table.entities.includes(this.name)) {
                table.addEntity(this);
            }
            // Set the Entity's table
            this._table = table;
            // If an entity tracking field is enabled, add the attributes, alias and the default
            if (table.Table.entityField) {
                this.schema.attributes[table.Table.entityField] = { type: 'string', alias: this._etAlias, default: this.name };
                this.defaults[table.Table.entityField] = this.name;
                this.schema.attributes[this._etAlias] = { type: 'string', map: table.Table.entityField, default: this.name };
                this.defaults[this._etAlias] = this.name;
            } // end if entity tracking
            // Throw an error if not a valid Table
        }
        else {
            utils_1.error('Invalid Table');
        }
    } // end set table
    // Returns the Entity's Table
    get table() {
        if (this._table) {
            return this._table;
        }
        else {
            return utils_1.error(`The '${this.name}' entity must be attached to a Table to perform this operation`);
        }
    }
    // Return reference to the DocumentClient
    get DocumentClient() {
        if (this.table.DocumentClient) {
            return this.table.DocumentClient;
        }
        else {
            return utils_1.error('DocumentClient required for this operation');
        }
    }
    // Sets the auto execute mode (default to true)
    set autoExecute(val) { this._execute = typeof val === 'boolean' ? val : undefined; }
    // Gets the current auto execute mode
    get autoExecute() {
        return typeof this._execute === 'boolean' ? this._execute
            : typeof this.table.autoExecute === 'boolean' ? this.table.autoExecute
                : true;
    }
    // Sets the auto parse mode (default to true)
    set autoParse(val) { this._parse = typeof val === 'boolean' ? val : undefined; }
    // Gets the current auto execute mode
    get autoParse() {
        return typeof this._parse === 'boolean' ? this._parse
            : typeof this.table.autoParse === 'boolean' ? this.table.autoParse
                : true;
    }
    // Primary key getters
    get partitionKey() {
        return this.schema.keys.partitionKey ?
            this.attribute(this.schema.keys.partitionKey)
            : utils_1.error(`No partitionKey defined`);
    }
    get sortKey() {
        return this.schema.keys.sortKey ?
            this.attribute(this.schema.keys.sortKey)
            : null;
    }
    // Get mapped attribute name
    attribute(attr) {
        return this.schema.attributes[attr] && this.schema.attributes[attr].map ?
            this.schema.attributes[attr].map
            : this.schema.attributes[attr] ? attr
                : utils_1.error(`'${attr}' does not exist or is an invalid alias`);
    } // end attribute
    // Parses the item
    parse(input, include = []) {
        // TODO: 'include' needs to handle nested maps?
        // Convert include to roots and de-alias
        include = include.map(attr => {
            const _attr = attr.split('.')[0].split('[')[0];
            return (this.schema.attributes[_attr] && this.schema.attributes[_attr].map) || _attr;
        });
        // Load the schema
        const { schema, linked } = this;
        // Assume standard response from DynamoDB
        const data = input.Item || input.Items || input;
        if (Array.isArray(data)) {
            return data.map(item => formatItem_1.default(this.DocumentClient)(schema.attributes, linked, item, include));
        }
        else {
            return formatItem_1.default(this.DocumentClient)(schema.attributes, linked, data, include);
        }
    } // end parse
    /**
     * Generate GET parameters and execute operation
     * @param {object} item - The keys from item you wish to get.
     * @param {object} [options] - Additional get options.
     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.
     */
    get(item = {}, options = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate the payload
            const payload = this.getParams(item, options, params);
            // If auto execute enabled
            if (options.execute || (this.autoExecute && options.execute !== false)) {
                const result = yield this.DocumentClient.get(payload).promise();
                // If auto parse enable
                if (options.parse || (this.autoParse && options.parse !== false)) {
                    return Object.assign(result, result.Item ? { Item: this.parse(result.Item, Array.isArray(options.include) ? options.include : []) } : null);
                }
                else {
                    return result;
                }
            }
            else {
                return payload;
            } // end if-else
        });
    } // end get
    /**
     * Generate parameters for GET batch operation
     * @param {object} item - The keys from item you wish to get.
     */
    getBatch(item = {}) {
        return {
            Table: this.table,
            Key: this.getParams(item).Key
        };
    }
    /**
     * Generate parameters for GET transaction operation
     * @param {object} item - The keys from item you wish to get.
     * @param {object} [options] - Additional get options
     *
     * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Get.html
     */
    getTransaction(item = {}, options = {}) {
        // Destructure options to check for extraneous arguments
        const { attributes } = options, // ProjectionExpression
        args = __rest(options
        // Error on extraneous arguments
        , ["attributes"]);
        // Error on extraneous arguments
        if (Object.keys(args).length > 0)
            utils_1.error(`Invalid get transaction options: ${Object.keys(args).join(', ')}`);
        // Generate the get parameters
        let payload = this.getParams(item, options);
        // Return in transaction format
        return {
            Entity: this,
            Get: payload
        };
    }
    /**
     * Generate GET parameters
     * @param {object} item - The keys from item you wish to get.
     * @param {object} [options] - Additional get options.
     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.
     */
    getParams(item = {}, options = {}, params = {}) {
        // Extract schema and merge defaults
        const { schema, defaults, linked, _table } = this;
        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);
        const { consistent, // ConsistentRead (boolean)
        capacity, // ReturnConsumedCapacity (none, total, or indexes)
        attributes } = options, // Projections
        _args = __rest(options
        // Remove other valid options from options
        , ["consistent", "capacity", "attributes"]);
        // Remove other valid options from options
        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));
        // Error on extraneous arguments
        if (args.length > 0)
            utils_1.error(`Invalid get options: ${args.join(', ')}`);
        // Verify consistent read
        if (consistent !== undefined && typeof consistent !== 'boolean')
            utils_1.error(`'consistent' requires a boolean`);
        // Verify capacity
        if (capacity !== undefined
            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))
            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);
        let ExpressionAttributeNames; // init ExpressionAttributeNames
        let ProjectionExpression; // init ProjectionExpression
        // If projections
        if (attributes) {
            const { names, projections } = projectionBuilder_1.default(attributes, this.table, this.name);
            if (Object.keys(names).length > 0) {
                // Merge names and add projection expression
                ExpressionAttributeNames = names;
                ProjectionExpression = projections;
            } // end if names
        } // end if projections
        // Generate the payload
        const payload = Object.assign({
            TableName: _table.name,
            Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)
        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, ProjectionExpression ? { ProjectionExpression } : null, consistent ? { ConsistentRead: consistent } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, typeof params === 'object' ? params : {});
        return payload;
    } // end getParams
    /**
     * Generate DELETE parameters and execute operation
     * @param {object} item - The keys from item you wish to delete.
     * @param {object} [options] - Additional delete options.
     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.
     */
    delete(item = {}, options = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = this.deleteParams(item, options, params);
            // If auto execute enabled
            if (options.execute || (this.autoExecute && options.execute !== false)) {
                const result = yield this.DocumentClient.delete(payload).promise();
                // If auto parse enable
                if (options.parse || (this.autoParse && options.parse !== false)) {
                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);
                }
                else {
                    return result;
                }
            }
            else {
                return payload;
            } // end if-else
        });
    } // end delete
    /**
     * Generate parameters for DELETE batch operation
     * @param {object} item - The keys from item you wish to delete.
     *
     * Only Key is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     */
    deleteBatch(item = {}) {
        const payload = this.deleteParams(item);
        return { [payload.TableName]: { DeleteRequest: { Key: payload.Key } } };
    }
    /**
     * Generate parameters for DELETE transaction operation
     * @param {object} item - The keys from item you wish to delete.
     * @param {object} [options] - Additional delete options
     *
     * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Delete.html
     */
    deleteTransaction(item = {}, options = {}) {
        // Destructure options to check for extraneous arguments
        const { conditions, // ConditionExpression
        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)
        args = __rest(options
        // Error on extraneous arguments
        , ["conditions", "returnValues"]);
        // Error on extraneous arguments
        if (Object.keys(args).length > 0)
            utils_1.error(`Invalid delete transaction options: ${Object.keys(args).join(', ')}`);
        // Generate the delete parameters
        let payload = this.deleteParams(item, options);
        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure
        if ('ReturnValues' in payload) {
            let { ReturnValues } = payload, _payload = __rest(payload, ["ReturnValues"]);
            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });
        }
        // Return in transaction format
        return { Delete: payload };
    }
    /**
     * Generate DELETE parameters
     * @param {object} item - The keys from item you wish to delete.
     * @param {object} [options] - Additional delete options.
     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.
     */
    deleteParams(item = {}, options = {}, params = {}) {
        // Extract schema and merge defaults
        const { schema, defaults, linked, _table } = this;
        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);
        const { conditions, // ConditionExpression
        capacity, // ReturnConsumedCapacity (none, total, or indexes)
        metrics, // ReturnItemCollectionMetrics: (size or none)
        returnValues } = options, // Return Values (none, all_old)
        _args = __rest(options
        // Remove other valid options from options
        , ["conditions", "capacity", "metrics", "returnValues"]);
        // Remove other valid options from options
        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));
        // Error on extraneous arguments
        if (args.length > 0)
            utils_1.error(`Invalid delete options: ${args.join(', ')}`);
        // Verify metrics
        if (metrics !== undefined
            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))
            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);
        // Verify capacity
        if (capacity !== undefined
            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))
            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);
        // Verify returnValues
        if (returnValues !== undefined
            && (typeof returnValues !== 'string'
                || !['NONE', 'ALL_OLD'].includes(returnValues.toUpperCase())))
            utils_1.error(`'returnValues' must be one of 'NONE' OR 'ALL_OLD'`);
        let ExpressionAttributeNames; // init ExpressionAttributeNames
        let ExpressionAttributeValues; // init ExpressionAttributeValues
        let ConditionExpression; // init ConditionExpression
        // If conditions
        if (conditions) {
            // Parse the conditions
            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);
            if (Object.keys(names).length > 0) {
                // TODO: alias attribute field names        
                // Merge names and values and add condition expression
                ExpressionAttributeNames = names;
                ExpressionAttributeValues = values;
                ConditionExpression = expression;
            } // end if names
        } // end if filters
        // Generate the payload
        const payload = Object.assign({
            TableName: _table.name,
            Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)
        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : null, ConditionExpression ? { ConditionExpression } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null, typeof params === 'object' ? params : {});
        return payload;
    } // end deleteParams
    /**
     * Generate UPDATE parameters and execute operations
     * @param {object} item - The keys from item you wish to update.
     * @param {object} [options] - Additional update options.
     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the update request.
     */
    update(item = {}, options = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate the payload
            const payload = this.updateParams(item, options, params);
            // If auto execute enabled
            if (options.execute || (this.autoExecute && options.execute !== false)) {
                const result = yield this.DocumentClient.update(payload).promise();
                // If auto parse enable
                if (options.parse || (this.autoParse && options.parse !== false)) {
                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);
                }
                else {
                    return result;
                }
            }
            else {
                return payload;
            } // end if-else
        });
    } // end delete
    /**
     * Generate parameters for UPDATE transaction operation
     * @param {object} item - The item you wish to update.
     * @param {object} [options] - Additional update options
     *
     * Creates an Update object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Update.html
     */
    updateTransaction(item = {}, options = {}) {
        // Destructure options to check for extraneous arguments
        const { conditions, // ConditionExpression
        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)
        args = __rest(options
        // Error on extraneous arguments
        , ["conditions", "returnValues"]);
        // Error on extraneous arguments
        if (Object.keys(args).length > 0)
            utils_1.error(`Invalid update transaction options: ${Object.keys(args).join(', ')}`);
        // Generate the update parameters
        let payload = this.updateParams(item, options);
        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure
        if ('ReturnValues' in payload) {
            let { ReturnValues } = payload, _payload = __rest(payload, ["ReturnValues"]);
            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });
        }
        // Return in transaction format (cast as Update since UpdateExpression can't be undefined)
        return { Update: payload };
    }
    // Generate UPDATE Parameters
    updateParams(item = {}, options = {}, _a = {}) {
        var { SET = [], REMOVE = [], ADD = [], DELETE = [], ExpressionAttributeNames = {}, ExpressionAttributeValues = {} } = _a, params = __rest(_a, ["SET", "REMOVE", "ADD", "DELETE", "ExpressionAttributeNames", "ExpressionAttributeValues"]);
        // Validate operation types
        if (!Array.isArray(SET))
            utils_1.error('SET must be an array');
        if (!Array.isArray(REMOVE))
            utils_1.error('REMOVE must be an array');
        if (!Array.isArray(ADD))
            utils_1.error('ADD must be an array');
        if (!Array.isArray(DELETE))
            utils_1.error('DELETE must be an array');
        // Validate attribute names and values
        if (typeof ExpressionAttributeNames !== 'object'
            || Array.isArray(ExpressionAttributeNames))
            utils_1.error('ExpressionAttributeNames must be an object');
        if (typeof ExpressionAttributeValues !== 'object'
            || Array.isArray(ExpressionAttributeValues))
            utils_1.error('ExpressionAttributeValues must be an object');
        // if (ConditionExpression && typeof ConditionExpression !== 'string')
        //     error(`ConditionExpression must be a string`)
        // Extract schema and defaults
        const { schema, defaults, required, linked, _table } = this;
        // Initialize validateType with the DocumentClient
        const validateType = validateTypes_1.default(this.DocumentClient);
        // Merge defaults
        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));
        // Extract valid options
        const { conditions, // ConditionExpression
        capacity, // ReturnConsumedCapacity (none, total, or indexes)
        metrics, // ReturnItemCollectionMetrics: (size or none)
        returnValues } = options, // Return Values (none, all_old, updated_old, all_new, updated_new)
        _args = __rest(options
        // Remove other valid options from options
        , ["conditions", "capacity", "metrics", "returnValues"]);
        // Remove other valid options from options
        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));
        // Error on extraneous arguments
        if (args.length > 0)
            utils_1.error(`Invalid update options: ${args.join(', ')}`);
        // Verify metrics
        if (metrics !== undefined
            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))
            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);
        // Verify capacity
        if (capacity !== undefined
            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))
            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);
        // Verify returnValues
        if (returnValues !== undefined
            && (typeof returnValues !== 'string'
                || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase())))
            utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', OR 'UPDATED_NEW'`);
        let ConditionExpression; // init ConditionExpression
        // If conditions
        if (conditions) {
            // Parse the conditions
            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);
            if (Object.keys(names).length > 0) {
                // TODO: alias attribute field names        
                // Add names, values and condition expression
                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);
                ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);
                ConditionExpression = expression;
            } // end if names
        } // end if conditions
        // Check for required fields
        Object.keys(required).forEach(field => required[field] && (data[field] === undefined || data[field] === null)
            && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check
        // Get partition and sort keys
        const Key = getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);
        // Init names and values
        const names = {};
        const values = {};
        // Loop through valid fields and add appropriate action
        Object.keys(data).forEach((field) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const mapping = schema.attributes[field];
            // Remove attributes
            if (field === '$remove') {
                const attrs = Array.isArray(data[field]) ? data[field] : [data[field]];
                for (const i in attrs) {
                    // Verify attribute
                    if (!schema.attributes[attrs[i]])
                        utils_1.error(`'${attrs[i]}' is not a valid attribute and cannot be removed`);
                    // Verify attribute is not a pk/sk
                    if (schema.attributes[attrs[i]].partitionKey === true || schema.attributes[attrs[i]].sortKey === true)
                        utils_1.error(`'${attrs[i]}' is the ${schema.attributes[attrs[i]].partitionKey === true ? 'partitionKey' : 'sortKey'} and cannot be removed`);
                    // Grab the attribute name and add to REMOVE and names
                    const attr = schema.attributes[attrs[i]].map || attrs[i];
                    REMOVE.push(`#${attr}`);
                    names[`#${attr}`] = attr;
                } // end for
            }
            else if (this._table._removeNulls === true && (data[field] === null || String(data[field]).trim() === '') && (!mapping.link || mapping.save)) {
                REMOVE.push(`#${field}`);
                names[`#${field}`] = field;
            }
            else if (
            // !mapping.partitionKey
            // && !mapping.sortKey
            mapping.partitionKey !== true
                && mapping.sortKey !== true
                && (mapping.save === undefined || mapping.save === true)
                && (!mapping.link || (mapping.link && mapping.save === true))) {
                // If a number or a set and adding
                if (['number', 'set'].includes(mapping.type) && (((_a = data[field]) === null || _a === void 0 ? void 0 : _a.$add) !== undefined && ((_b = data[field]) === null || _b === void 0 ? void 0 : _b.$add) !== null)) {
                    ADD.push(`#${field} :${field}`);
                    values[`:${field}`] = validateType(mapping, field, data[field].$add);
                    // Add field to names
                    names[`#${field}`] = field;
                    // if a set and deleting items
                }
                else if (mapping.type === 'set' && ((_c = data[field]) === null || _c === void 0 ? void 0 : _c.$delete)) {
                    DELETE.push(`#${field} :${field}`);
                    values[`:${field}`] = validateType(mapping, field, data[field].$delete);
                    // Add field to names
                    names[`#${field}`] = field;
                    // if a list and removing items by index
                }
                else if (mapping.type === 'list' && Array.isArray((_d = data[field]) === null || _d === void 0 ? void 0 : _d.$remove)) {
                    data[field].$remove.forEach((i) => {
                        if (typeof i !== 'number')
                            utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);
                        REMOVE.push(`#${field}[${i}]`);
                    });
                    // Add field to names
                    names[`#${field}`] = field;
                    // if list and appending or prepending
                }
                else if (mapping.type === 'list' && (((_e = data[field]) === null || _e === void 0 ? void 0 : _e.$append) || ((_f = data[field]) === null || _f === void 0 ? void 0 : _f.$prepend))) {
                    if (data[field].$append) {
                        SET.push(`#${field} = list_append(#${field},:${field})`);
                        values[`:${field}`] = validateType(mapping, field, data[field].$append);
                    }
                    else {
                        SET.push(`#${field} = list_append(:${field},#${field})`);
                        values[`:${field}`] = validateType(mapping, field, data[field].$prepend);
                    }
                    // Add field to names
                    names[`#${field}`] = field;
                    // if a list and updating by index
                }
                else if (mapping.type === 'list' && !Array.isArray(data[field]) && typeof data[field] === 'object') {
                    Object.keys(data[field]).forEach(i => {
                        if (String(parseInt(i)) !== i)
                            utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);
                        SET.push(`#${field}[${i}] = :${field}_${i}`);
                        values[`:${field}_${i}`] = data[field][i];
                    });
                    // Add field to names
                    names[`#${field}`] = field;
                    // if a map and updating by nested attribute/index
                }
                else if (mapping.type === 'map' && ((_g = data[field]) === null || _g === void 0 ? void 0 : _g.$set)) {
                    Object.keys(data[field].$set).forEach(f => {
                        // TODO: handle null values to remove
                        let props = f.split('.');
                        let acc = [`#${field}`];
                        props.forEach((prop, i) => {
                            let id = `${field}_${props.slice(0, i + 1).join('_')}`;
                            // Add names and values
                            names[`#${id.replace(/\[(\d+)\]/, '')}`] = prop.replace(/\[(\d+)\]/, '');
                            // if the final prop, add the SET and values
                            if (i === props.length - 1) {
                                let input = data[field].$set[f];
                                let path = `${acc.join('.')}.#${id}`;
                                let value = `${id.replace(/\[(\d+)\]/, '_$1')}`;
                                if (input === undefined) {
                                    REMOVE.push(`${path}`);
                                }
                                else if (input.$add) {
                                    ADD.push(`${path} :${value}`);
                                    values[`:${value}`] = input.$add;
                                }
                                else if (input.$append) {
                                    SET.push(`${path} = list_append(${path},:${value})`);
                                    values[`:${value}`] = input.$append;
                                }
                                else if (input.$prepend) {
                                    SET.push(`${path} = list_append(:${value},${path})`);
                                    values[`:${value}`] = input.$prepend;
                                }
                                else if (input.$remove) {
                                    // console.log('REMOVE:',input.$remove);
                                    input.$remove.forEach((i) => {
                                        if (typeof i !== 'number')
                                            utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);
                                        REMOVE.push(`${path}[${i}]`);
                                    });
                                }
                                else {
                                    SET.push(`${path} = :${value}`);
                                    values[`:${value}`] = input;
                                }
                                if (input.$set) {
                                    Object.keys(input.$set).forEach(i => {
                                        if (String(parseInt(i)) !== i)
                                            utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);
                                        SET.push(`${path}[${i}] = :${value}_${i}`);
                                        values[`:${value}_${i}`] = input.$set[i];
                                    });
                                }
                            }
                            else {
                                acc.push(`#${id.replace(/\[(\d+)\]/, '')}`);
                            }
                        });
                    });
                    // Add field to names
                    names[`#${field}`] = field;
                    // else add to SET
                }
                else {
                    let value = utils_1.transformAttr(mapping, validateType(mapping, field, data[field]), data);
                    // It's possible that defaults can purposely return undefined values
                    // if (hasValue(value)) {
                    if (value !== undefined) {
                        // Push the update to SET
                        // @ts-ignore
                        SET.push(mapping.default !== undefined && item[field] === undefined && !mapping.onUpdate ?
                            `#${field} = if_not_exists(#${field},:${field})`
                            : `#${field} = :${field}`);
                        // Add names and values
                        names[`#${field}`] = field;
                        values[`:${field}`] = value;
                    }
                }
            } // end if undefined
        });
        // Create the update expression
        const expression = ((SET.length > 0 ? 'SET ' + SET.join(', ') : '')
            + (REMOVE.length > 0 ? ' REMOVE ' + REMOVE.join(', ') : '')
            + (ADD.length > 0 ? ' ADD ' + ADD.join(', ') : '')
            + (DELETE.length > 0 ? ' DELETE ' + DELETE.join(', ') : '')).trim();
        // Merge attribute values
        ExpressionAttributeValues = Object.assign(values, ExpressionAttributeValues);
        // Generate the payload
        const payload = Object.assign({
            TableName: _table.name,
            Key,
            UpdateExpression: expression,
            ExpressionAttributeNames: Object.assign(names, ExpressionAttributeNames)
        }, typeof params === 'object' ? params : {}, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : {}, ConditionExpression ? { ConditionExpression } : {}, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null); // end assign
        return payload;
        // TODO: Check why primary/secondary GSIs are using if_not_exists
    } // end updateParams
    // PUT - put item
    put(item = {}, options = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // Generate the payload
            const payload = this.putParams(item, options, params);
            // If auto execute enabled
            if (options.execute || (this.autoExecute && options.execute !== false)) {
                const result = yield this.DocumentClient.put(payload).promise();
                // If auto parse enable
                if (options.parse || (this.autoParse && options.parse !== false)) {
                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);
                }
                else {
                    return result;
                }
            }
            else {
                return payload;
            } // end-if
        });
    } // end put
    /**
     * Generate parameters for PUT batch operation
     * @param {object} item - The item you wish to put.
     *
     * Only Item is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     */
    putBatch(item = {}) {
        const payload = this.putParams(item);
        return { [payload.TableName]: { PutRequest: { Item: payload.Item } } };
    }
    /**
     * Generate parameters for PUT transaction operation
     * @param {object} item - The item you wish to put.
     * @param {object} [options] - Additional put options
     *
     * Creates a Put object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Put.html
     */
    putTransaction(item = {}, options = {}) {
        // Destructure options to check for extraneous arguments
        const { conditions, // ConditionExpression
        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)
        args = __rest(options
        // Error on extraneous arguments
        , ["conditions", "returnValues"]);
        // Error on extraneous arguments
        if (Object.keys(args).length > 0)
            utils_1.error(`Invalid put transaction options: ${Object.keys(args).join(', ')}`);
        // Generate the put parameters
        let payload = this.putParams(item, options);
        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure
        if ('ReturnValues' in payload) {
            let { ReturnValues } = payload, _payload = __rest(payload, ["ReturnValues"]);
            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });
        }
        // Return in transaction format
        return { Put: payload };
    }
    // Generate PUT Parameters
    putParams(item = {}, options = {}, params = {}) {
        // Extract schema and defaults
        const { schema, defaults, required, linked, _table } = this;
        // Initialize validateType with the DocumentClient
        const validateType = validateTypes_1.default(this.DocumentClient);
        // Merge defaults
        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));
        // console.log(data);
        // Extract valid options
        const { conditions, // ConditionExpression
        capacity, // ReturnConsumedCapacity (none, total, or indexes)
        metrics, // ReturnItemCollectionMetrics: (size or none)
        returnValues } = options, // Return Values (none, all_old, updated_old, all_new, updated_new)
        _args = __rest(options
        // Remove other valid options from options
        , ["conditions", "capacity", "metrics", "returnValues"]);
        // Remove other valid options from options
        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));
        // Error on extraneous arguments
        if (args.length > 0)
            utils_1.error(`Invalid put options: ${args.join(', ')}`);
        // Verify metrics
        if (metrics !== undefined
            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))
            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);
        // Verify capacity
        if (capacity !== undefined
            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))
            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);
        // Verify returnValues
        // TODO: Check this, conflicts with dynalite
        if (returnValues !== undefined
            && (typeof returnValues !== 'string'
                || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase())))
            utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', or 'UPDATED_NEW'`);
        let ExpressionAttributeNames; // init ExpressionAttributeNames
        let ExpressionAttributeValues; // init ExpressionAttributeValues
        let ConditionExpression; // init ConditionExpression
        // If conditions
        if (conditions) {
            // Parse the conditions
            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);
            if (Object.keys(names).length > 0) {
                // TODO: alias attribute field names        
                // Add names, values and condition expression
                ExpressionAttributeNames = names;
                ExpressionAttributeValues = values;
                ConditionExpression = expression;
            } // end if names
        } // end if filters
        // Check for required fields
        Object.keys(required).forEach(field => required[field] !== undefined && (data[field] === undefined || data[field] === null)
            && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check
        // Checks for partition and sort keys
        getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);
        // Generate the payload
        const payload = Object.assign({
            TableName: _table.name,
            // Loop through valid fields and add appropriate action
            Item: Object.keys(data).reduce((acc, field) => {
                let mapping = schema.attributes[field];
                let value = validateType(mapping, field, data[field]);
                return value !== undefined
                    && (mapping.save === undefined || mapping.save === true)
                    && (!mapping.link || (mapping.link && mapping.save === true))
                    && (!_table._removeNulls || (_table._removeNulls && value !== null))
                    ? Object.assign(acc, {
                        [field]: utils_1.transformAttr(mapping, value, data)
                    }) : acc;
            }, {})
        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : null, ConditionExpression ? { ConditionExpression } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null, typeof params === 'object' ? params : {});
        return payload;
    } // end putParams
    /**
     * Generate parameters for ConditionCheck transaction operation
     * @param {object} item - The keys from item you wish to check.
     * @param {object} [options] - Additional condition check options
     *
     * Creates a ConditionCheck object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ConditionCheck.html
     */
    conditionCheck(item = {}, options = {}) {
        // Destructure options to check for extraneous arguments
        const { conditions, // ConditionExpression
        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)
        args = __rest(options
        // Error on extraneous arguments
        , ["conditions", "returnValues"]);
        // Error on extraneous arguments
        if (Object.keys(args).length > 0)
            utils_1.error(`Invalid conditionCheck options: ${Object.keys(args).join(', ')}`);
        // Generate the condition parameters (same params as delete)
        let payload = this.deleteParams(item, options);
        // Error on missing conditions
        if (!('ConditionExpression' in payload))
            utils_1.error(`'conditions' are required in a conditionCheck`);
        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure
        if ('ReturnValues' in payload) {
            let { ReturnValues } = payload, _payload = __rest(payload, ["ReturnValues"]);
            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });
        }
        // Return in transaction format
        return { ConditionCheck: payload };
    }
    // Query pass-through (default entity)
    query(pk, options = {}, params = {}) {
        options.entity = this.name;
        return this.table.query(pk, options, params);
    }
    // Scan pass-through (default entity)
    scan(options = {}, params = {}) {
        options.entity = this.name;
        return this.table.scan(options, params);
    }
} // end Entity
// Export the Entity class
exports.default = Entity;
