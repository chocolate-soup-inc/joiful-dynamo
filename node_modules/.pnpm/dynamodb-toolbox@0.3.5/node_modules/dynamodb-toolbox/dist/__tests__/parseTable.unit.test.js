"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseTable_1 = __importDefault(require("../lib/parseTable"));
let table = {
    name: 'test-table',
    alias: 'test-table-alias',
    partitionKey: 'pk',
    sortKey: 'sk',
    entityField: 'entity',
    attributes: { pk: 'string', sk: 'string' },
    indexes: { GSI: { partitionKey: 'GSIpk', sortKey: 'GSIsk' } },
    autoExecute: false,
    autoParse: false
};
describe('parseTable', () => {
    it('parses simple mapping', () => __awaiter(void 0, void 0, void 0, function* () {
        let tbl = parseTable_1.default(table);
        expect(tbl.name).toBe('test-table');
        expect(tbl.alias).toBe('test-table-alias');
        expect(tbl.Table.attributes.entity).toEqual({ type: 'string', mappings: {} });
        expect(tbl.Table.attributes.pk).toEqual({ type: 'string', mappings: {} });
        expect(tbl.Table.attributes.sk).toEqual({ type: 'string', mappings: {} });
        expect(tbl.Table.entityField).toBe('entity');
        expect(tbl._entities).toEqual([]);
        expect(tbl.autoExecute).toBe(false);
        expect(tbl.autoParse).toBe(false);
    }));
    it('fails on extra config option', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { invalidConfig: true }));
        }).toThrow(`Invalid Table configuration options: invalidConfig`);
    }));
    it('fails if missing name', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { name: undefined }));
        }).toThrow(`'name' must be defined`);
    }));
    it('fails if alias is not a string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { alias: 123 }));
        }).toThrow(`'alias' must be a string value`);
    }));
    it('fails if missing partitionKey', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { partitionKey: undefined }));
        }).toThrow(`'partitionKey' must be defined`);
    }));
    it('fails if sortKey is not a strin', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { sortKey: 123 }));
        }).toThrow(`'sortKey' must be a string value`);
    }));
    it('fails if attributes is not an object', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { attributes: 'string' }));
        }).toThrow(`Please provide a valid 'attributes' object`);
    }));
    it('passes if attributes is null', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseTable_1.default(Object.assign({}, table, { attributes: null }))).toHaveProperty('Table');
    }));
    it('passes if attributes is undefined', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseTable_1.default(Object.assign({}, table, { attributes: undefined }))).toHaveProperty('Table');
    }));
    it('fails if indexes is not an object', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { indexes: 'string' }));
        }).toThrow(`Please provide a valid 'indexes' object`);
    }));
    it('fails if index contain extra arguments', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { indexes: { GSI: { partitionKey: 'pk', invalidParam: true } } }));
        }).toThrow(`Invalid index options: invalidParam`);
    }));
    it('fails if index partitionKey is not a string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { indexes: { GSI: { partitionKey: 123 } } }));
        }).toThrow(`'partitionKey' for GSI must be a string`);
    }));
    it('fails if index sortKey is not a string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { indexes: { GSI: { sortKey: 123 } } }));
        }).toThrow(`'sortKey' for GSI must be a string`);
    }));
    it('fails if index does not contain partitionKey or sortKey', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseTable_1.default(Object.assign({}, table, { indexes: { GSI: {} } }));
        }).toThrow(`A 'partitionKey', 'sortKey' or both, must be provided for GSI`);
    }));
});
