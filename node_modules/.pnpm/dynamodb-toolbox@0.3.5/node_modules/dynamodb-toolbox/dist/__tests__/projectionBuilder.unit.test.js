"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const projectionBuilder_1 = __importDefault(require("../lib/projectionBuilder"));
// Require Table and Entity classes
const Table_1 = __importDefault(require("../classes/Table"));
const Entity_1 = __importDefault(require("../classes/Entity"));
// Create basic table
let DefaultTable = new Table_1.default({
    name: 'test-table',
    partitionKey: 'pk',
    sortKey: 'sk'
});
// Create basic entity
const User = new Entity_1.default({
    name: 'User',
    attributes: {
        family: { type: 'string', partitionKey: true },
        name: { type: 'string', sortKey: true },
        set: { type: 'set', setType: 'string', alias: 'roles' },
        age: 'number',
        friends: 'list',
        test: 'map',
        test2: { type: 'map', alias: 'mapAlias' }
    },
    table: DefaultTable
});
const Pet = new Entity_1.default({
    name: 'Pet',
    attributes: {
        family: { type: 'string', partitionKey: true },
        name: { type: 'string', sortKey: true },
        petType: 'string'
    },
    table: DefaultTable
});
describe('projectionBuilder', () => {
    it('generate test projection expression', () => {
        const proj = [
            'pk',
            'sk',
            'petType',
            'test2.path',
            { User: ['family', 'name', 'roles', 'test.subpath', 'friends[1]'] }
        ];
        // Get projection with type
        const result = projectionBuilder_1.default(proj, DefaultTable, null, true);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk',
            '#proj3': 'petType',
            '#proj4': 'test2.path',
            '#proj5': 'set',
            '#proj6': 'test.subpath',
            '#proj7': 'friends[1]',
            '#proj8': '_et'
        });
        expect(result.projections).toBe('#proj1,#proj2,#proj3,#proj4,#proj5,#proj6,#proj7,#proj8');
    });
    it('fails when no table is passed', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default(['pk']);
        }).toThrow('Tables must be valid and contain attributes');
    });
    it('fails when invalid table is passed', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default(['pk'], { test: true });
        }).toThrow('Tables must be valid and contain attributes');
    });
    it('converts string to array', () => {
        // Get projection with type
        const result = projectionBuilder_1.default('pk,sk,test', DefaultTable, null, false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk',
            '#proj3': 'test'
        });
        expect(result.projections).toBe('#proj1,#proj2,#proj3');
    });
    it('accepts object input', () => {
        const proj = { User: ['family', 'name'] };
        // Get projection with type
        const result = projectionBuilder_1.default(proj, DefaultTable, null, false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk'
        });
        expect(result.projections).toBe('#proj1,#proj2');
    });
    it('uses an entity alias', () => {
        const proj = ['family', 'name'];
        // Get projection with type
        const result = projectionBuilder_1.default(proj, DefaultTable, 'User', false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk'
        });
        expect(result.projections).toBe('#proj1,#proj2');
    });
    it('parses string from object assignment', () => {
        const proj = { User: 'family,name' };
        // Get projection with type
        const result = projectionBuilder_1.default(proj, DefaultTable, null, false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk'
        });
        expect(result.projections).toBe('#proj1,#proj2');
    });
    it('merges mulitple entity references of the same type', () => {
        const proj = [{ User: 'family,name' }, { User: 'test' }];
        // Get projection with type
        const result = projectionBuilder_1.default(proj, DefaultTable, null, false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk',
            '#proj3': 'test'
        });
        expect(result.projections).toBe('#proj1,#proj2,#proj3');
    });
    it('fails when invalid type is passed in object', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default({ User: {} }, DefaultTable);
        }).toThrow('Only arrays or strings are supported');
    });
    it('fails when projections are not strings', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default({ User: ['pk', []] }, DefaultTable);
        }).toThrow('Entity projections must be string values');
    });
    it('fails when entity is invalid', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default({ Test: 'pk,sk' }, DefaultTable);
        }).toThrow(`'Test' is not a valid entity on this table`);
    });
    it('fails when projection is an invalid type', () => {
        expect(() => {
            // @ts-expect-error
            projectionBuilder_1.default(['pk', 1], DefaultTable);
        }).toThrow(`'number' is an invalid type. Projections require strings or arrays`);
    });
    it('skips duplicate attributes', () => {
        // Get projection with type
        const result = projectionBuilder_1.default('pk,sk,pk', DefaultTable, null, false);
        // console.log(JSON.stringify(result.names,null,2))
        expect(result.names).toEqual({
            '#proj1': 'pk',
            '#proj2': 'sk'
        });
        expect(result.projections).toBe('#proj1,#proj2');
    });
});
