"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const bootstrap_tests_1 = require("./bootstrap-tests");
const TestTable = new index_1.Table({
    name: 'test-table',
    partitionKey: 'pk',
    sortKey: 'sk',
    indexes: { GSI1: { partitionKey: 'GSI1pk', sortKey: 'GSIsk1' } },
    DocumentClient: bootstrap_tests_1.DocumentClient,
    autoExecute: false
});
const TestEntity = new index_1.Entity({
    name: 'TestEntity',
    autoExecute: false,
    attributes: {
        email: { type: 'string', partitionKey: true },
        sort: { type: 'string', sortKey: true },
        test: 'string'
    },
    table: TestTable
});
describe('table.get', () => {
    it('gets an entity from the table', () => __awaiter(void 0, void 0, void 0, function* () {
        let result = yield TestTable.get('TestEntity', { email: 'val1', sort: 'val2' });
        expect(result).toEqual({ TableName: 'test-table', Key: { pk: 'val1', sk: 'val2' } });
    }));
    it('fails on invalid entity when performing a get', () => {
        expect(TestTable.get('TestEntityX')).rejects.toThrow(`'TestEntityX' is not a valid Entity`);
    });
});
describe('table.delete', () => {
    it('deletes an entity from the table', () => __awaiter(void 0, void 0, void 0, function* () {
        let result = yield TestTable.delete('TestEntity', { email: 'val1', sort: 'val2' });
        expect(result).toEqual({ TableName: 'test-table', Key: { pk: 'val1', sk: 'val2' } });
    }));
    it('fails on invalid entity when performing a delete', () => {
        expect(TestTable.delete('TestEntityX')).rejects.toThrow(`'TestEntityX' is not a valid Entity`);
    });
});
describe('table.update', () => {
    it('updates an entity from the table', () => __awaiter(void 0, void 0, void 0, function* () {
        let result = yield TestTable.update('TestEntity', {
            email: 'val1',
            sort: 'val2',
            test: 'testing'
        });
        expect(result.TableName).toBe('test-table');
        expect(result.Key).toEqual({ pk: 'val1', sk: 'val2' });
        expect(result.UpdateExpression).toBe('SET #_ct = if_not_exists(#_ct,:_ct), #_md = :_md, #_et = if_not_exists(#_et,:_et), #test = :test');
    }));
    it('fails on invalid entity when performing an update', () => {
        expect(TestTable.update('TestEntityX')).rejects.toThrow(`'TestEntityX' is not a valid Entity`);
    });
});
describe('table.put', () => {
    it('puts an entity to the table', () => __awaiter(void 0, void 0, void 0, function* () {
        let result = yield TestTable.put('TestEntity', { email: 'val1', sort: 'val2', test: 'testing' });
        expect(result.TableName).toBe('test-table');
        expect(result.Item.pk).toBe('val1');
        expect(result.Item.sk).toBe('val2');
        expect(result.Item.test).toBe('testing');
    }));
    it('fails on invalid entity when performing a put', () => {
        expect(TestTable.put('TestEntityX')).rejects.toThrow(`'TestEntityX' is not a valid Entity`);
    });
});
describe('table.parse', () => {
    it('parses single item', () => __awaiter(void 0, void 0, void 0, function* () {
        let item = yield TestTable.parse(TestEntity.name, {
            pk: 'test@test.com',
            sk: 'email',
            test: 'testing',
            _et: TestEntity.name
        });
        expect(item).toEqual({
            email: 'test@test.com',
            sort: 'email',
            test: 'testing',
            entity: TestEntity.name
        });
    }));
    it('fails on invalid entity when performing a parse', () => {
        // @ts-expect-error
        expect(TestTable.parse('TestEntityX')).rejects.toThrow(`'TestEntityX' is not a valid Entity`);
    });
}); // end table.parse
