"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Require Table and Entity classes
const Table_1 = __importDefault(require("../classes/Table"));
const Entity_1 = __importDefault(require("../classes/Entity"));
describe('Entity properties', () => {
    it('fails if trying to add a table when one already exists', () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true }
            },
            table: TestTable
        });
        expect(() => {
            TestEntity.table = TestTable;
        }).toThrow('This entity is already assigned a Table (test-table)');
    }));
    it('fails if assigning an invalid Table', () => __awaiter(void 0, void 0, void 0, function* () {
        // Create invalid tTable
        const TestTable = {};
        expect(() => {
            // Create basic entity
            // @ts-expect-error
            new Entity_1.default({
                name: 'TestEnt',
                attributes: {
                    pk: { partitionKey: true }
                },
                table: TestTable
            });
        }).toThrow('Invalid Table');
    }));
    it(`fails if trying to get 'table' if not attached`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true }
            }
        });
        expect(() => {
            TestEntity.table;
        }).toThrow(`The 'TestEnt' entity must be attached to a Table to perform this operation`);
    }));
    it(`fails if trying to get 'DocumentClient' if not on table`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true }
            },
            table: TestTable
        });
        expect(() => {
            TestEntity.DocumentClient;
        }).toThrow(`DocumentClient required for this operation`);
    }));
    it(`gets/sets the autoExecute and autoParse settings`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            autoExecute: false,
            autoParse: false
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true }
            },
            table: TestTable
        });
        expect(TestEntity.autoExecute).toBe(false);
        expect(TestEntity.autoParse).toBe(false);
        TestEntity.autoExecute = true;
        TestEntity.autoParse = true;
        expect(TestEntity.autoExecute).toBe(true);
        expect(TestEntity.autoParse).toBe(true);
    }));
    it(`gets the partitionKey and sortKey`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            sortKey: 'sk'
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true },
                sk: { sortKey: true }
            },
            table: TestTable
        });
        expect(TestEntity.partitionKey).toBe('pk');
        expect(TestEntity.sortKey).toBe('sk');
    }));
    it(`gets a null sortKey`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true }
            },
            table: TestTable
        });
        expect(TestEntity.sortKey).toBeNull();
    }));
    it(`gets an attribute by name and mapping`, () => __awaiter(void 0, void 0, void 0, function* () {
        // Create basic table
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        // Create basic entity
        const TestEntity = new Entity_1.default({
            name: 'TestEnt',
            attributes: {
                pk: { partitionKey: true },
                test: { map: 'sk' }
            },
            table: TestTable
        });
        expect(TestEntity.attribute('pk')).toBe('pk');
        expect(TestEntity.attribute('test')).toBe('sk');
        expect(() => {
            TestEntity.attribute('missing');
        }).toThrow(`'missing' does not exist or is an invalid alias`);
    }));
});
