"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const checkAttribute_1 = __importDefault(require("../lib/checkAttribute"));
// Require Table and Entity classes
const Table_1 = __importDefault(require("../classes/Table"));
const Entity_1 = __importDefault(require("../classes/Entity"));
// Create basic table
let DefaultTable = new Table_1.default({
    name: 'test-table',
    partitionKey: 'pk',
    sortKey: 'sk'
});
// Create basic entity
DefaultTable.addEntity(new Entity_1.default({
    name: 'User',
    attributes: {
        pk: { type: 'string', partitionKey: true },
        sk: { type: 'string', sortKey: true },
        set: { type: 'set', setType: 'string', alias: 'set_alias' },
        set_alias2: { type: 'set', setType: 'string', map: 'set2' },
        number: 'number',
        list: { type: 'list', alias: 'list_alias' },
        list_alias2: { type: 'list', map: 'list2' },
        test: 'map'
    }
}));
describe('checkAttribute', () => {
    it('checks attribute and returns table attribute', () => {
        expect(checkAttribute_1.default('number', DefaultTable.User.schema.attributes)).toBe('number');
        expect(checkAttribute_1.default('set', DefaultTable.User.schema.attributes)).toBe('set');
        expect(checkAttribute_1.default('set_alias', DefaultTable.User.schema.attributes)).toBe('set');
        expect(checkAttribute_1.default('set2', DefaultTable.User.schema.attributes)).toBe('set2');
        expect(checkAttribute_1.default('set_alias2', DefaultTable.User.schema.attributes)).toBe('set2');
        expect(checkAttribute_1.default('set.test', DefaultTable.User.schema.attributes)).toBe('set.test');
        expect(checkAttribute_1.default('set.test[0]', DefaultTable.User.schema.attributes)).toBe('set.test[0]');
        expect(checkAttribute_1.default('set.test.test2[0]', DefaultTable.User.schema.attributes)).toBe('set.test.test2[0]');
        expect(checkAttribute_1.default('set_alias.test', DefaultTable.User.schema.attributes)).toBe('set.test');
        expect(checkAttribute_1.default('set_alias.test[0]', DefaultTable.User.schema.attributes)).toBe('set.test[0]');
        expect(checkAttribute_1.default('set_alias.test.test2[0]', DefaultTable.User.schema.attributes)).toBe('set.test.test2[0]');
        expect(checkAttribute_1.default('set_alias2.test', DefaultTable.User.schema.attributes)).toBe('set2.test');
        expect(checkAttribute_1.default('set_alias2.test[0]', DefaultTable.User.schema.attributes)).toBe('set2.test[0]');
        expect(checkAttribute_1.default('set_alias2.test.test2[0]', DefaultTable.User.schema.attributes)).toBe('set2.test.test2[0]');
        expect(checkAttribute_1.default('test.test', DefaultTable.User.schema.attributes)).toBe('test.test');
        expect(checkAttribute_1.default('test.test[0]', DefaultTable.User.schema.attributes)).toBe('test.test[0]');
        expect(checkAttribute_1.default('list[1]', DefaultTable.User.schema.attributes)).toBe('list[1]');
        expect(checkAttribute_1.default('list[1]', DefaultTable.User.schema.attributes)).toBe('list[1]');
    });
    it('returns error on invalid attribute', () => {
        expect(() => {
            checkAttribute_1.default('missing-attribute', DefaultTable.User.schema.attributes);
        }).toThrow(`'missing-attribute' is not a valid attribute.`);
    });
});
