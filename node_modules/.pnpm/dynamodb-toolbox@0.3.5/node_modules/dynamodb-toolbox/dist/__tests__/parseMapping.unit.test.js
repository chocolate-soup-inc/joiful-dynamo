"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseMapping_1 = __importDefault(require("../lib/parseMapping"));
let track = {
    fields: [],
    defaults: [],
    required: [],
    linked: {},
    keys: []
};
beforeEach(() => {
    track = {
        fields: [],
        defaults: [],
        required: [],
        linked: {},
        keys: []
    };
});
describe('parseMapping', () => {
    it('parses simple mapping', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string' }, track)).toEqual({
            attr: { type: 'string', coerce: true }
        });
    }));
    it('parses mapping with coerce set to false', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', coerce: false }, track)).toEqual({
            attr: { type: 'string', coerce: false }
        });
    }));
    it('fails on non-boolean coerce', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', coerce: 'false' }, track);
        }).toThrow(`'coerce' must be a boolean`);
    }));
    it('parses mapping with onUpdate', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', onUpdate: true }, track)).toEqual({
            attr: { type: 'string', coerce: true, onUpdate: true }
        });
    }));
    it('parses mapping with hidden', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', hidden: true }, track)).toEqual({
            attr: { type: 'string', coerce: true, hidden: true }
        });
    }));
    it('parses mapping with save', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', save: true }, track)).toEqual({
            attr: { type: 'string', coerce: true, save: true }
        });
    }));
    it('parses mapping with required (true)', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', required: true }, track)).toEqual({
            attr: { type: 'string', coerce: true, required: true }
        });
    }));
    it('parses mapping with required (always)', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', required: 'always' }, track)).toEqual({
            attr: { type: 'string', coerce: true, required: 'always' }
        });
    }));
    it('fails on non-boolean required', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', required: 'false' }, track);
        }).toThrow(`'required' must be a boolean`);
    }));
    it('fails on non-string map/alias', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', map: 1 }, track);
        }).toThrow(`'map' must be a unique string`);
    }));
    it('fails on empty string value for map/alias', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', map: ' ' }, track);
        }).toThrow(`'map' must be a unique string`);
    }));
    it('fails on duplicate alias or map field', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', map: 'attr1' }, Object.assign({}, track, { fields: ['attr1'] }));
        }).toThrow(`'map' must be a unique string`);
    }));
    it('fails when a partitionKey field has an alias', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', partitionKey: true, alias: 'attr1' }, track);
        }).toThrow(`Attributes with a partitionKey cannot have a 'map' or 'alias' associated`);
    }));
    it('fails when a partitionKey field has a map', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', partitionKey: true, map: 'attr1' }, track);
        }).toThrow(`Attributes with a partitionKey cannot have a 'map' or 'alias' associated`);
    }));
    it('fails when a sortKey field has an alias', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', sortKey: true, alias: 'attr1' }, track);
        }).toThrow(`Attributes with a sortKey cannot have a 'map' or 'alias' associated`);
    }));
    it('fails when a sortKey field has a map', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', sortKey: true, map: 'attr1' }, track);
        }).toThrow(`Attributes with a sortKey cannot have a 'map' or 'alias' associated`);
    }));
    it('parses partitionKey as string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', partitionKey: 'GSI' }, track)).toEqual({
            attr: { type: 'string', partitionKey: 'GSI', coerce: true }
        });
    }));
    it('parses partitionKey as an array', () => __awaiter(void 0, void 0, void 0, function* () {
        // @ts-expect-error ðŸ’¥ TODO: Support GSIs
        expect(parseMapping_1.default('attr', { type: 'string', partitionKey: [true, 'GSI'] }, track)).toEqual({
            attr: { type: 'string', partitionKey: [true, 'GSI'], coerce: true }
        });
    }));
    it('fails when a partitionKey has already been defined', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', partitionKey: true }, Object.assign({}, track, { keys: { partitionKey: 'pk' } }));
        }).toThrow(`'pk' has already been declared as the partitionKey`);
    }));
    it('ignores partitionKey marked false', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(parseMapping_1.default('attr', { type: 'string', partitionKey: false }, track)).toEqual({
            attr: { type: 'string', partitionKey: false, coerce: true }
        });
    }));
    it('fails when partitionKey and sortKey are both used', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', sortKey: true }, Object.assign({}, track, { keys: { partitionKey: 'attr' } }));
        }).toThrow(`'attr' attribute cannot be both the partitionKey and sortKey`);
    }));
    it('fails when partitionKey is not a boolean or string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            // @ts-expect-error
            parseMapping_1.default('attr', { type: 'string', partitionKey: {} }, { keys: {} });
        }).toThrow(`'partitionKey' must be a boolean, string, or array`);
    }));
    it('fails when partitionKey for index has already been assigned', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', partitionKey: 'GSI' }, Object.assign({}, track, { keys: { GSI: { partitionKey: 'GSIpk' } } }));
        }).toThrow(`'GSIpk' has already been declared as the partitionKey for the GSI index`);
    }));
    it('fails when partitionKey index assignment is not a string', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', 
            // @ts-expect-error
            { type: 'string', partitionKey: [{}] }, Object.assign({}, track, { keys: { GSI: { partitionKey: 'GSIpk' } } }));
        }).toThrow(`Index assignments for 'attr' must be string or boolean values`);
    }));
    it('fails when partitionKey index is also the sortKey', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', sortKey: 'GSI' }, Object.assign({}, track, { keys: { GSI: { partitionKey: 'attr' } } }));
        }).toThrow(`'attr' attribute cannot be both the partitionKey and sortKey for the GSI index`);
    }));
    it('fails if map and alias are both set', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(() => {
            parseMapping_1.default('attr', { type: 'string', map: 'test', alias: 'testx' }, track);
        }).toThrow(`'attr' cannot contain both an alias and a map`);
    }));
});
