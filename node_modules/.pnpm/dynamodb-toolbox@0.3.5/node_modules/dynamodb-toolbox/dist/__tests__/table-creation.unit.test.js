"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Bootstrap testing
const bootstrap_tests_1 = require("./bootstrap-tests");
// Require Table and Entity classes
const Table_1 = __importDefault(require("../classes/Table"));
describe('Table creation', () => {
    it('creates table w/ minimum options', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBeNull();
        expect(TestTable.Table.entityField).toBe('_et');
        expect(TestTable.Table.indexes).toEqual({});
        expect(TestTable.Table.attributes).toEqual({ _et: { type: 'string', mappings: {} } });
        expect(TestTable.autoExecute).toBe(true);
        expect(TestTable.autoParse).toBe(true);
        expect(TestTable.entities).toEqual([]);
    })); // end table
    it('creates table w/ options', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            sortKey: 'sk',
            entityField: 'entity',
            autoExecute: false,
            autoParse: false
        });
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBe('sk');
        expect(TestTable.Table.entityField).toBe('entity');
        expect(TestTable.Table.indexes).toEqual({});
        expect(TestTable.Table.attributes).toEqual({ entity: { type: 'string', mappings: {} } });
        expect(TestTable.autoExecute).toBe(false);
        expect(TestTable.autoParse).toBe(false);
        expect(TestTable.entities).toEqual([]);
    })); // end table w/ options
    it('creates table w/ attributes', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            attributes: {
                stringAttr: 'string',
                numberAttr: 'number',
                binaryAttr: 'binary',
                booleanAttr: 'boolean',
                listAttr: 'list',
                mapAttr: 'map',
                stringSetAttr: 'set',
                numberSetAttr: { type: 'set', setType: 'number' },
                binarySetAttr: { type: 'set', setType: 'binary' }
            }
        });
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBeNull();
        expect(TestTable.Table.entityField).toBe('_et');
        expect(TestTable.Table.indexes).toEqual({});
        expect(TestTable.autoExecute).toBe(true);
        expect(TestTable.autoParse).toBe(true);
        expect(TestTable.entities).toEqual([]);
        // Check attribute parsing
        expect(TestTable.Table.attributes).toEqual({
            stringAttr: { type: 'string', mappings: {} },
            numberAttr: { type: 'number', mappings: {} },
            binaryAttr: { type: 'binary', mappings: {} },
            booleanAttr: { type: 'boolean', mappings: {} },
            listAttr: { type: 'list', mappings: {} },
            mapAttr: { type: 'map', mappings: {} },
            stringSetAttr: { type: 'set', mappings: {} },
            numberSetAttr: { type: 'set', setType: 'number', mappings: {} },
            binarySetAttr: { type: 'set', setType: 'binary', mappings: {} },
            _et: { type: 'string', mappings: {} }
        });
    })); // end table w/ attributes
    it('creates table w/ indexes', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            indexes: {
                // GSI w/ pk and sk
                GSI1: { partitionKey: 'GSI1pk', sortKey: 'GSI1sk' },
                // GSI w/ only pk
                GSI2: { partitionKey: 'GSI2pk' },
                // LSI w/ reused pk
                LSI1: { partitionKey: 'pk', sortKey: 'LSI1sk' },
                // LSI w/ only sk
                LSI2: { sortKey: 'LSI2sk' }
            }
        });
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBeNull();
        expect(TestTable.Table.entityField).toBe('_et');
        expect(TestTable.Table.attributes).toEqual({ _et: { type: 'string', mappings: {} } });
        expect(TestTable.autoExecute).toBe(true);
        expect(TestTable.autoParse).toBe(true);
        expect(TestTable.entities).toEqual([]);
        // Verify index parsing
        expect(TestTable.Table.indexes).toEqual({
            GSI1: { partitionKey: 'GSI1pk', sortKey: 'GSI1sk', type: 'GSI' },
            GSI2: { partitionKey: 'GSI2pk', type: 'GSI' },
            LSI1: { sortKey: 'LSI1sk', type: 'LSI' },
            LSI2: { sortKey: 'LSI2sk', type: 'LSI' }
        });
    })); // end table w/ indexes
    it('creates table w/ DocumentClient', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk',
            DocumentClient: bootstrap_tests_1.DocumentClient
        });
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.DocumentClient.constructor.name).toBe('DocumentClient');
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBeNull();
        expect(TestTable.Table.entityField).toBe('_et');
        expect(TestTable.Table.indexes).toEqual({});
        expect(TestTable.Table.attributes).toEqual({ _et: { type: 'string', mappings: {} } });
        expect(TestTable.autoExecute).toBe(true);
        expect(TestTable.autoParse).toBe(true);
        expect(TestTable.entities).toEqual([]);
    })); // end create table w/ DocumentClient
    it('creates table, then add DocumentClient', () => __awaiter(void 0, void 0, void 0, function* () {
        const TestTable = new Table_1.default({
            name: 'test-table',
            partitionKey: 'pk'
        });
        // Add the DocumentClient
        TestTable.DocumentClient = bootstrap_tests_1.DocumentClient;
        expect(TestTable instanceof Table_1.default).toBe(true);
        expect(TestTable.DocumentClient.constructor.name).toBe('DocumentClient');
        expect(TestTable.name).toBe('test-table');
        expect(TestTable.Table.partitionKey).toBe('pk');
        expect(TestTable.Table.sortKey).toBeNull();
        expect(TestTable.Table.entityField).toBe('_et');
        expect(TestTable.Table.indexes).toEqual({});
        expect(TestTable.Table.attributes).toEqual({ _et: { type: 'string', mappings: {} } });
        expect(TestTable.autoExecute).toBe(true);
        expect(TestTable.autoParse).toBe(true);
        expect(TestTable.entities).toEqual([]);
    })); // end create table w/ DocumentClient
});
