"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAttributes = exports.joiSchema = exports.validate = exports.getPropertyValidate = exports.getValidatedFields = void 0;
require("reflect-metadata");
const joi_1 = __importDefault(require("joi"));
const hasOne_1 = require("./hasOne");
const hasMany_1 = require("./hasMany");
const validateMetadataKey = Symbol('validate');
const getValidatedFields = (target) => {
    return Reflect.getMetadata(validateMetadataKey, target) || [];
};
exports.getValidatedFields = getValidatedFields;
const getPropertyValidate = (target, key) => {
    return Reflect.getMetadata(validateMetadataKey, target, key);
};
exports.getPropertyValidate = getPropertyValidate;
function validate(joi) {
    return (target, propertyKey) => {
        // ADD THE JOI SCHEMA TO THE METADATA
        Reflect.defineMetadata(validateMetadataKey, joi, target, propertyKey);
        // SET THE LIST OF VALIDATED PROPERTIES IN THE INSTANCE
        let properties = Reflect.getMetadata(validateMetadataKey, target);
        if (properties) {
            properties.push(propertyKey);
        }
        else {
            properties = [propertyKey];
            Reflect.defineMetadata(validateMetadataKey, properties, target);
        }
    };
}
exports.validate = validate;
function joiSchema(target) {
    const validatedKeys = (0, exports.getValidatedFields)(target);
    const joiObject = joi_1.default.object().unknown(true);
    const hasOneNestedModels = (0, hasOne_1.getHasOneNestedModels)(target);
    const hasManyNestedModels = (0, hasMany_1.getHasManyNestedModels)(target);
    const allNestedModels = hasOneNestedModels.concat(hasManyNestedModels);
    const hasOneNotNestedModels = (0, hasOne_1.getHasOneNotNestedModels)(target);
    const hasManyNotNestedModels = (0, hasMany_1.getHasManyNotNestedModels)(target);
    const allNotNestedModels = hasOneNotNestedModels.concat(hasManyNotNestedModels);
    const allModels = allNestedModels.concat(allNotNestedModels);
    // THIS WILL IGNORE ALL THE MODELS (NESTED AND NOT NESTED) FROM THE SCHEMA
    const joiKeys = validatedKeys.reduce((agg, key) => {
        const schema = (0, exports.getPropertyValidate)(target, key);
        if (!allModels.includes(key) && schema != null)
            agg[key] = schema;
        return agg;
    }, {});
    // THIS WILL RE-ADD THE NESTED MODELS TO THE SCHEMA
    [{
            modelsArray: hasOneNestedModels,
            getModelFunc: hasOne_1.getHasOneModel,
        }, {
            modelsArray: hasManyNestedModels,
            getModelFunc: hasMany_1.getHasManyModel,
        }].forEach(({ modelsArray, getModelFunc }) => {
        for (const model of modelsArray) {
            const { model: ModelClass, opts, } = getModelFunc(target, model) || {};
            let schema = joiSchema(ModelClass.prototype);
            if (schema != null) {
                if (opts && opts.required) {
                    schema = schema.required();
                }
                joiKeys[model] = schema;
            }
        }
    });
    if (Object.keys(joiKeys).length > 0)
        return joiObject.keys(joiKeys);
    return joiObject;
}
exports.joiSchema = joiSchema;
function validateAttributes(target, item) {
    const schema = joiSchema(target);
    const { value, error } = schema.validate(item, {
        abortEarly: false,
        convert: true,
        dateFormat: 'iso',
    });
    if (error)
        throw error;
    return value;
}
exports.validateAttributes = validateAttributes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXMiOlsibGliL2RlY29yYXRvcnMvdmFsaWRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNEJBQTBCO0FBQzFCLDhDQUFzQjtBQUN0QixxQ0FBMkY7QUFDM0YsdUNBQStGO0FBRS9GLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBRXhDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxNQUFXLEVBQVksRUFBRTtJQUMxRCxPQUFPLE9BQU8sQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2hFLENBQUMsQ0FBQztBQUZXLFFBQUEsa0JBQWtCLHNCQUU3QjtBQUVLLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxNQUFXLEVBQUUsR0FBVyxFQUEwQixFQUFFO0lBQ3RGLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDL0QsQ0FBQyxDQUFDO0FBRlcsUUFBQSxtQkFBbUIsdUJBRTlCO0FBRUYsU0FBZ0IsUUFBUSxDQUFDLEdBQWU7SUFDdEMsT0FBTyxDQUFDLE1BQVcsRUFBRSxXQUFtQixFQUFRLEVBQUU7UUFDaEQscUNBQXFDO1FBQ3JDLE9BQU8sQ0FBQyxjQUFjLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUV0RSx1REFBdUQ7UUFDdkQsSUFBSSxVQUFVLEdBQWEsT0FBTyxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU1RSxJQUFJLFVBQVUsRUFBRTtZQUNkLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDOUI7YUFBTTtZQUNMLFVBQVUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sQ0FBQyxjQUFjLENBQUMs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dEMsSUFBSSxFQUNKO1FBQ0UsVUFBVSxFQUFFLEtBQUs7UUFDakIsT0FBTyxFQUFFLElBQUk7UUFDYixVQUFVLEVBQUUsS0FBSztLQUNsQixDQUNGLENBQUM7SUFFRixJQUFJLEtBQUs7UUFBRSxNQUFNLEtBQUssQ0FBQztJQUN2QixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFkRCxnREFjQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XG5pbXBvcnQgSm9pIGZyb20gJ2pvaSc7XG5pbXBvcnQgeyBnZXRIYXNPbmVNb2RlbCwgZ2V0SGFzT25lTmVzdGVkTW9kZWxzLCBnZXRIYXNPbmVOb3ROZXN0ZWRNb2RlbHMgfSBmcm9tICcuL2hhc09uZSc7XG5pbXBvcnQgeyBnZXRIYXNNYW55TW9kZWwsIGdldEhhc01hbnlOZXN0ZWRNb2RlbHMsIGdldEhhc01hbnlOb3ROZXN0ZWRNb2RlbHMgfSBmcm9tICcuL2hhc01hbnknO1xuXG5jb25zdCB2YWxpZGF0ZU1ldGFkYXRhS2V5ID0gU3ltYm9sKCd2YWxpZGF0ZScpO1xuXG5leHBvcnQgY29uc3QgZ2V0VmFsaWRhdGVkRmllbGRzID0gKHRhcmdldDogYW55KTogc3RyaW5nW10gPT4ge1xuICByZXR1cm4gUmVmbGVjdC5nZXRNZXRhZGF0YSh2YWxpZGF0ZU1ldGFkYXRhS2V5LCB0YXJnZXQpIHx8IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFByb3BlcnR5VmFsaWRhdGUgPSAodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nKTogSm9pLlNjaGVtYSB8IHVuZGVmaW5lZCA9PiB7XG4gIHJldHVybiBSZWZsZWN0LmdldE1ldGFkYXRhKHZhbGlkYXRlTWV0YWRhdGFLZXksIHRhcmdldCwga2V5KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShqb2k6IEpvaS5TY2hlbWEpIHtcbiAgcmV0dXJuICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgIC8vIEFERCBUSEUgSk9JIFNDSEVNQSBUTyBUSEUgTUVUQURBVEFcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKHZhbGlkYXRlTWV0YWRhdGFLZXksIGpvaSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG5cbiAgICAvLyBTRVQgVEhFIExJU1QgT0YgVkFMSURBVEVEIFBST1BFUlRJRVMgSU4gVEhFIElOU1RBTkNFXG4gICAgbGV0IHByb3BlcnRpZXM6IHN0cmluZ1tdID0gUmVmbGVjdC5nZXRNZXRhZGF0YSh2YWxpZGF0ZU1ldGFkYXRhS2V5LCB0YXJnZXQpO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BlcnRpZXMgPSBbcHJvcGVydHlLZXldO1xuICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSh2YWxpZGF0ZU1ldGFkYXRhS2V5LCBwcm9wZXJ0aWVzLCB0YXJnZXQpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaVNjaGVtYSh0YXJnZXQ6IGFueSkge1xuICBjb25zdCB2YWxpZGF0ZWRLZXlzID0gZ2V0VmFsaWRhdGVkRmllbGRzKHRhcmdldCk7XG4gIGNvbnN0IGpvaU9iamVjdCA9IEpvaS5vYmplY3QoKS51bmtub3duKHRydWUpO1xuXG4gIGNvbnN0IGhhc09uZU5lc3RlZE1vZGVscyA9IGdldEhhc09uZU5lc3RlZE1vZGVscyh0YXJnZXQpO1xuICBjb25zdCBoYXNNYW55TmVzdGVkTW9kZWxzID0gZ2V0SGFzTWFueU5lc3RlZE1vZGVscyh0YXJnZXQpO1xuICBjb25zdCBhbGxOZXN0ZWRNb2RlbHMgPSBoYXNPbmVOZXN0ZWRNb2RlbHMuY29uY2F0KGhhc01hbnlOZXN0ZWRNb2RlbHMpO1xuXG4gIGNvbnN0IGhhc09uZU5vdE5lc3RlZE1vZGVscyA9IGdldEhhc09uZU5vdE5lc3RlZE1vZGVscyh0YXJnZXQpO1xuICBjb25zdCBoYXNNYW55Tm90TmVzdGVkTW9kZWxzID0gZ2V0SGFzTWFueU5vdE5lc3RlZE1vZGVscyh0YXJnZXQpO1xuICBjb25zdCBhbGxOb3ROZXN0ZWRNb2RlbHMgPSBoYXNPbmVOb3ROZXN0ZWRNb2RlbHMuY29uY2F0KGhhc01hbnlOb3ROZXN0ZWRNb2RlbHMpO1xuXG4gIGNvbnN0IGFsbE1vZGVscyA9IGFsbE5lc3RlZE1vZGVscy5jb25jYXQoYWxsTm90TmVzdGVkTW9kZWxzKTtcblxuICAvLyBUSElTIFdJTEwgSUdOT1JFIEFMTCBUSEUgTU9ERUxTIChORVNURUQgQU5EIE5PVCBORVNURUQpIEZST00gVEhFIFNDSEVNQVxuICBjb25zdCBqb2lLZXlzID0gdmFsaWRhdGVkS2V5cy5yZWR1Y2UoKGFnZywga2V5KSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0UHJvcGVydHlWYWxpZGF0ZSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFhbGxNb2RlbHMuaW5jbHVkZXMoa2V5KSAmJiBzY2hlbWEgIT0gbnVsbCkgYWdnW2tleV0gPSBzY2hlbWE7XG4gICAgcmV0dXJuIGFnZztcbiAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgSm9pLlNjaGVtYT4pO1xuXG4gIC8vIFRISVMgV0lMTCBSRS1BREQgVEhFIE5FU1RFRCBNT0RFTFMgVE8gVEhFIFNDSEVNQVxuICBbe1xuICAgIG1vZGVsc0FycmF5OiBoYXNPbmVOZXN0ZWRNb2RlbHMsXG4gICAgZ2V0TW9kZWxGdW5jOiBnZXRIYXNPbmVNb2RlbCxcbiAgfSwge1xuICAgIG1vZGVsc0FycmF5OiBoYXNNYW55TmVzdGVkTW9kZWxzLFxuICAgIGdldE1vZGVsRnVuYzogZ2V0SGFzTWFueU1vZGVsLFxuICB9XS5mb3JFYWNoKCh7IG1vZGVsc0FycmF5LCBnZXRNb2RlbEZ1bmMgfSkgPT4ge1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzQXJyYXkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbW9kZWw6IE1vZGVsQ2xhc3MsXG4gICAgICAgIG9wdHMsXG4gICAgICB9ID0gZ2V0TW9kZWxGdW5jKHRhcmdldCwgbW9kZWwpIHx8IHt9O1xuXG4gICAgICBsZXQgc2NoZW1hID0gam9pU2NoZW1hKE1vZGVsQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnJlcXVpcmVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBqb2lLZXlzW21vZGVsXSA9IHNjaGVtYTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChPYmplY3Qua2V5cyhqb2lLZXlzKS5sZW5ndGggPiAwKSByZXR1cm4gam9pT2JqZWN0LmtleXMoam9pS2V5cyk7XG4gIHJldHVybiBqb2lPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF0dHJpYnV0ZXModGFyZ2V0OiBhbnksIGl0ZW06IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgY29uc3Qgc2NoZW1hID0gam9pU2NoZW1hKHRhcmdldCk7XG5cbiAgY29uc3QgeyB2YWx1ZSwgZXJyb3IgfSA9IHNjaGVtYS52YWxpZGF0ZShcbiAgICBpdGVtLFxuICAgIHtcbiAgICAgIGFib3J0RWFybHk6IGZhbHNlLFxuICAgICAgY29udmVydDogdHJ1ZSxcbiAgICAgIGRhdGVGb3JtYXQ6ICdpc28nLFxuICAgIH0sXG4gICk7XG5cbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgcmV0dXJuIHZhbHVlO1xufVxuIl19